<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>为什么要测试 | Jest 实践指南</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="从基础实战到测试思维，带你全面了解和掌握前端测试">
    <meta name="keywords" content="jest, testing, typescript, eslint, 前端, 测试">
    <meta name="author" content="海怪">
    
    <link rel="preload" href="/jest-tutorial/assets/css/0.styles.3af8d58b.css" as="style"><link rel="preload" href="/jest-tutorial/assets/js/app.dfa51a05.js" as="script"><link rel="preload" href="/jest-tutorial/assets/js/2.03a6ea53.js" as="script"><link rel="preload" href="/jest-tutorial/assets/js/25.1c35c041.js" as="script"><link rel="prefetch" href="/jest-tutorial/assets/js/10.a5fde7bb.js"><link rel="prefetch" href="/jest-tutorial/assets/js/11.0e357828.js"><link rel="prefetch" href="/jest-tutorial/assets/js/12.d675dd1f.js"><link rel="prefetch" href="/jest-tutorial/assets/js/13.ff10ad5b.js"><link rel="prefetch" href="/jest-tutorial/assets/js/14.1903c055.js"><link rel="prefetch" href="/jest-tutorial/assets/js/15.b6d0931c.js"><link rel="prefetch" href="/jest-tutorial/assets/js/16.6a29a918.js"><link rel="prefetch" href="/jest-tutorial/assets/js/17.d31ffd05.js"><link rel="prefetch" href="/jest-tutorial/assets/js/18.8509fe90.js"><link rel="prefetch" href="/jest-tutorial/assets/js/19.0c05163f.js"><link rel="prefetch" href="/jest-tutorial/assets/js/20.55eba354.js"><link rel="prefetch" href="/jest-tutorial/assets/js/21.5edf9c70.js"><link rel="prefetch" href="/jest-tutorial/assets/js/22.77f22525.js"><link rel="prefetch" href="/jest-tutorial/assets/js/23.3e072b91.js"><link rel="prefetch" href="/jest-tutorial/assets/js/24.d8220887.js"><link rel="prefetch" href="/jest-tutorial/assets/js/26.d4b69710.js"><link rel="prefetch" href="/jest-tutorial/assets/js/3.9fccf44d.js"><link rel="prefetch" href="/jest-tutorial/assets/js/4.2d7ecec7.js"><link rel="prefetch" href="/jest-tutorial/assets/js/5.b1a8dea6.js"><link rel="prefetch" href="/jest-tutorial/assets/js/6.ee81796b.js"><link rel="prefetch" href="/jest-tutorial/assets/js/7.45845233.js"><link rel="prefetch" href="/jest-tutorial/assets/js/8.8fda6116.js"><link rel="prefetch" href="/jest-tutorial/assets/js/9.89aee88f.js">
    <link rel="stylesheet" href="/jest-tutorial/assets/css/0.styles.3af8d58b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jest-tutorial/" class="home-link router-link-active"><img src="/jest-tutorial/images/logo.png" alt="Jest 实践指南" class="logo"> <span class="site-name can-hide">Jest 实践指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/haixiangyan/jest-tutorial/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Issue
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/haixiangyan/jest-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/haixiangyan/jest-tutorial/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Issue
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/haixiangyan/jest-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>介绍</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jest-tutorial/" aria-current="page" class="sidebar-link">小书介绍</a></li><li><a href="/jest-tutorial/intro/why-test/" aria-current="page" class="active sidebar-link">为什么要测试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#为什么要测试" class="sidebar-link">为什么要测试</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#优化流程" class="sidebar-link">优化流程</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#保证质量" class="sidebar-link">保证质量</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#优化更新项目的后盾" class="sidebar-link">优化更新项目的后盾</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#测试驱动开发" class="sidebar-link">测试驱动开发</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#用例即例子" class="sidebar-link">用例即例子</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#提升个人能力" class="sidebar-link">提升个人能力</a></li><li class="sidebar-sub-header"><a href="/jest-tutorial/intro/why-test/#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>基础实践</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jest-tutorial/basic/getting-started/" class="sidebar-link">起步</a></li><li><a href="/jest-tutorial/basic/transformer/" class="sidebar-link">转译器</a></li><li><a href="/jest-tutorial/basic/test-environment/" class="sidebar-link">测试环境</a></li><li><a href="/jest-tutorial/basic/navigation/" class="sidebar-link">Mock 网页地址</a></li><li><a href="/jest-tutorial/basic/tdd/" class="sidebar-link">测试驱动开发</a></li><li><a href="/jest-tutorial/basic/mock-timer/" class="sidebar-link">Mock Timer</a></li><li><a href="/jest-tutorial/basic/config-react/" class="sidebar-link">引入 React（纯配置）</a></li><li><a href="/jest-tutorial/basic/snapshot-test/" class="sidebar-link">快照测试</a></li><li><a href="/jest-tutorial/basic/component-test/" class="sidebar-link">组件测试</a></li><li><a href="/jest-tutorial/basic/how-to-mock/" class="sidebar-link">Mock 大全</a></li><li><a href="/jest-tutorial/basic/redux-test/" class="sidebar-link">Redux 测试</a></li><li><a href="/jest-tutorial/basic/hook-test/" class="sidebar-link">React Hook 测试</a></li><li><a href="/jest-tutorial/basic/static-tool/" class="sidebar-link">静态检查工具</a></li><li><a href="/jest-tutorial/basic/performance/" class="sidebar-link">Jest 性能优化</a></li><li><a href="/jest-tutorial/basic/automation/" class="sidebar-link">自动化测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>测试思路</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jest-tutorial/thoughts/articles.html" class="sidebar-link">所有文章</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>最后</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jest-tutorial/end/github.html" class="sidebar-link">Github 项目</a></li><li><a href="/jest-tutorial/end/end.html" class="sidebar-link">结语</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="为什么要测试"><a href="#为什么要测试" class="header-anchor">#</a> 为什么要测试</h2> <p>一谈到单测，可能大家的第一反应都是敬而远之。</p> <blockquote><p><strong>没啥用，没时间，我不会</strong></p></blockquote> <p>我承认写单测是个非常有挑战性，且难度不小的活，但 <strong>我依然推荐大家尝试去写一写单元测试，因为它所带来的好处不仅仅是大家想的那么简单：“只是 Bug 少了一点”</strong>。 所以，<strong>我会尝试从另外一些角度来讨论单测可以给我们带来哪些好处。</strong></p> <h2 id="优化流程"><a href="#优化流程" class="header-anchor">#</a> 优化流程</h2> <p>接着刚刚说到的 “只是 Bug 少一点” 这句话，可能大多数觉得单测就是在提测前减少一点 Bug 而已：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3364ba640d443e7bb4ce5eca49d1a1a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这样的想法确实是最直观的。但这只是想到了第一层，如果我们把 <strong>开发流程所有步骤</strong> 都加进来，会发现是这样的：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/235e9c8636374d338641fc8ed4fff6fa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>在 <code>开发过程</code> 后面，几乎每个流程都可能抛出 Bug。<strong>越是到后面流程才抛出的 Bug，程序员就越是要投入比开发阶段更大的时间和业务，而且所承受的风险也是最高的。</strong></p> <p>或许大家会想：不就改个 Bug，改几行而已。 <strong>可是大家有没有想过在跟测的过程中，很可能你已经开始另一个需求的评审了！</strong> 此时的你在解决突然插入的 Bug 的时候，心态还会像刚开始写代码时候那么轻松么？</p> <p>实际上，还有更多的隐性成本没有考虑，<strong>比如反复确认产品逻辑、反复确认交互设计、反复确认前后端接口设计、各端对产品的理解。</strong> 有的时候，你就会发现这样很魔幻的场景：明明是一个字段的展示问题，竟然要花上一上午，拉了 4、5 个人来开会核对的情况。</p> <p>下面这张图，也在说明两个问题：一是 85% 的缺陷都在代码设计阶段产生；二是发现 Bug 的阶段越靠后，耗费成本就越高，呈指数级别的增长。这种 “指数成本” 的案例也经常发生，当我们改正一个 Bug 的时候，可能随之而来又会多出 3 个 Bug，俗称：<strong>改崩了。</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dc5069bfff84135b32f8940715c2c4c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p><strong>所以，在早期的单元测试就能发现bug，不仅可以省时省力，在开发流程上提高效率，也能降低反复修改出现的风险和时间成本。</strong></p> <h2 id="保证质量"><a href="#保证质量" class="header-anchor">#</a> 保证质量</h2> <p>这一节主题就是大家经常想的：减少 Bug 率。我们不妨来想一个问题：<strong>什么才是 Bug？</strong> 相信所有开发人员都不愿意写 Bug，在 <strong>《软件测试》</strong> 这本书中将 Bug 描述成 “软件缺陷”，里面说道：</p> <blockquote><p>大多数的 “软件缺陷” 并非源自编程错误，对众多从小到大的项目进行研究而得出的结论往往是一致的，导致软件缺陷最大的原因是产品说明书！见下图</p></blockquote> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58cc7c6deab74de9b7d900935d34d664~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>大多数的产品还是能够写出一份清晰明了的需求单的，奈何 ta 也不可能把所有情况想都枚举出来，这也导致了开发时很容易出现考虑不周全的情况。<strong>往往能够发现异常情况的人要么是测试、要么是交互视觉、要么是后期产品体验。</strong> 那到这个时候才发现的问题，然后再去修复又会出现的 <strong>指数爆炸的成本</strong>。</p> <p>如果把实现功能看成走迷宫，把找到通路看成上线需求， <strong>那么编码实现的过程就像从入口找出口，而单元测试则像从出口找入口。</strong> 这种开两个线程 “双向奔赴” 的找通路方法能够用最精准最快的方式找到通路。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d176624866416184fd183f1a670146~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>单测所保障的不仅仅只是代码的正确性，毕竟大家在边开发边 Debug 的时候已经能验证 99% 的正确性了，而单测更大的地方在于 <strong>让我们不得不去思考到一些异常情况</strong> ，这无形中就能增强代码的质量。</p> <h2 id="优化更新项目的后盾"><a href="#优化更新项目的后盾" class="header-anchor">#</a> 优化更新项目的后盾</h2> <p>可能大家对上面这一节也不以为意，我能理解大家的侥幸心理。毕竟在公司里，开发写完 Bug，然后交给测试找出来是大家其乐融融表现。而且不写测试大家过得还挺好的，也没出什么大乱子。</p> <p>造成这样的错觉在两个方面：<strong>一是测试找 Bug，开发再 Debug，这确实能解决燃眉之急，短期内很有效果。二是需求一直不断快速迭代，一期的 Bug，二期还能合着去改，二期改不了还有三期，三期结束了还有四期......</strong> 。</p> <p>这种永无止境的测试 + 开发模式能在一定程度上让我们的代码 <strong>“看起来是有保障的”</strong> 。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd00b5dc94404943aea524e400dc1bdc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>人肉测试固然好用，但是也有下面的缺点：</p> <ul><li>使用一次成本非常高</li> <li>回归测试成本更高</li> <li>只有到上线功能的时候才会使用一次人力测试来轰炸</li></ul> <p>由于成本很高，人肉测试一般只会用来测业务功能，并没有太多测试资源可以分配到优化需求、技术需求上。 <strong>所以对于这类需求只能通过前端开发人员自测，到目前为止也只是优化一个点，然后点点鼠标来自测，效率并不高。一旦优化过程中改出了问题，回滚、和修复的成本又会非常高，这也会助长大家 “不敢优化”、“能不动就不动” 的思想。</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4283da0c0f94446a9216f65829261166~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p><strong>如果能有一定量的测试，则有足够强大的信心来支撑项目的优化，也有助于整个项目的未来发展和改进。</strong></p> <h2 id="测试驱动开发"><a href="#测试驱动开发" class="header-anchor">#</a> 测试驱动开发</h2> <p>测试驱动开发（Testing-Driven Development）是敏捷开发中的一项核心实践和技术，也是一种设计方法论。</p> <p><strong>上面说的单测特点比较偏向于 “防守”，而 TDD 中的测试则偏向于 “进攻”。</strong> TDD 的原理是在开发功能代码之前，先编写单元测试用例代码，在此基础上再补充产品代码。比如要实现 <code>getUserById</code> 这个服务，那么可以先写如下测试，然后再补充 <code>getUserById</code> 的实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'getUserById'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'可以根据 id 返回用户信息'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: getUserById 未实现</span>
    <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token string">'122'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token string">'122'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这种方法在 Node 端非常实用。由于 Node 端要依赖的项非常多，比如数据库、各方接口、配置中心等等。每次用 Postman 去测接口，就会一次性将多个模块以及服务一起测了。 <strong>如果别的服务还在开发或者有问题，就会直接阻塞了接口的开发。</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7045c1cea674dd5a928f055ba7c816f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>虽然 Postman 在接口测试的时候很好用，但是它也有如下缺点：</p> <ul><li><strong>用例不足。</strong> 由于 Postman 一般只做简单的接口测试，并不像单测那样会把所有分支情况都枚举</li> <li><strong>用例无法共享。</strong> 虽然 Postman 也能写简单的用例，但是现在每个人的 Postman 会有自己的用例，难以覆盖所有情况</li> <li><strong>用例无法保鲜。</strong> 当接口更新了之后，Postman 的用例可能存在过期的情况</li></ul> <p><strong>单元测试则很好地填补了这一块，利用单测强大的 Mock 能力先将依赖项都 Mock 掉，开发时可以只关注某个函数、服务的开发，不会受其依赖项干扰：</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77788c9e58224baba8366ca5a75c1162~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>由于每次提交代码都应该保证测试通过率 100%，所以我们也不会担心这些例子是否过期的问题。</p> <h2 id="用例即例子"><a href="#用例即例子" class="header-anchor">#</a> 用例即例子</h2> <p>测试用例还有个很好的功能：<strong>将使用案例记录在案。</strong></p> <p>很多时候别人写一些工具函数和方法，使用者是不能一眼就能学会怎么用的。往往这时写函数的人就会说：<strong>你看 XXX 文件就知道怎么用了。</strong> 但这些 “真实例子” 中通常会夹杂着很多依赖项，无法作用一个最小 Use Case 来理解。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567c665c9c2840b698d960bbd57e0d10~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p><strong>而单测里的每个用例都可以看成一个最小的 <code>example</code>，通过阅读 Test Case 就能马上知道这个函数怎么使用了。</strong> 这里举 redux 的 <code>compose</code> 函数的例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'Utils'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'compose'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'composes from right to left'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token function-variable function">double</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">x</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span>
      <span class="token keyword">const</span> <span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">x</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> x
      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span>
      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> double<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>double<span class="token punctuation">,</span> square<span class="token punctuation">,</span> double<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>就算我们不知道 <code>compose</code> 是用来干嘛的，但是我们很清楚地知道，使用方法就是从右到左地执行回调。</p> <p><strong>由于每次发布时我们都要保证单测 100% 通过率，所以永远不用担心这个 Use Case 无法使用、过期的问题。</strong></p> <h2 id="提升个人能力"><a href="#提升个人能力" class="header-anchor">#</a> 提升个人能力</h2> <p>抛开这些项目质量、优化流程的原因，推荐大家写单测的另一重要原因就是 <strong>提升个人能力</strong>。</p> <p>几乎所有 Jest 的入门文章的开头都会有一个非常简单的 Test Case：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">expect</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这很容易让人误以为单测很简单，以为不就是学一个框架那样嘛。然而，只有在真正编写测试用例的时候才会发现单测的难度呈指数级上涨。 <strong>因为测试的本身是另一个领域，是需要通过不断练习才能掌握测试技巧的。</strong> 对前端单测来说，它的难度包括但不限于如下几点：</p> <ul><li><strong>测试框架与开发框架的不配合。</strong> 比如版本冲突问题</li> <li><strong>模拟环境问题。</strong> 比如模拟浏览器环境，往往项目一出现 <code>localStorage</code>，<code>cookie</code> 这些浏览器独有的东西时，Jest 就会报错，很多人受不了直接放弃了</li> <li><strong>不同框架、库的测试方法都是需要学习的</strong>。有的框架 Nest.js 有 <code>@nestjs/testing</code>，React.js 有 <code>react-testing-library</code>。有的库 Redux 又会有自己独特的 testing guide</li></ul> <p>总的来说，写单测并不像大家想的这么简单，<code>jest</code> 只是个开始的地方。不过，从另一个角度来看，如果你能坚持写好单测，对个人能力也大有裨益：</p> <ul><li><strong>提升不同环境的 Mock 能力。</strong> 掌握不同测试框架的测试技巧</li> <li><strong>提升异常分支的感知能力。</strong> 写代码的时候也能代入测试者视角，在开发时能马上发现并处理异常分支</li> <li><strong>了解并实践更多的测试策略。</strong> 如自上而下、自下而上，影子数据库等</li> <li><strong>为简历增光添彩。</strong> 在写测试的过程中我们也可以深入测试这个领域，将编程知识融会贯通</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>稍微总结一下，单测可以在 <strong>优化开发流程、保证项目质量、给项目优化上保险、驱动开发、提供 Use Case、提升个人能力</strong> 方面有着非常大的益处。</p> <p>当然，这一章也是希望大家能够多尝试自己领域之外的东西，不要固步自封。对个人而言，多练习写单测能力肯定是好处多于坏处。现在，让我们开始测试之旅吧。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">5/20/2022, 11:27:43 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jest-tutorial/" class="prev router-link-active">
        小书介绍
      </a></span> <span class="next"><a href="/jest-tutorial/basic/getting-started/">
        起步
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/jest-tutorial/assets/js/app.dfa51a05.js" defer></script><script src="/jest-tutorial/assets/js/2.03a6ea53.js" defer></script><script src="/jest-tutorial/assets/js/25.1c35c041.js" defer></script>
  </body>
</html>
